Bot.py

import discord
from discord.ext import commands
import finnhub
import pandas as pd
import numpy as np
import ta
import asyncio
import json
import os
from datetime import datetime

# === CONFIGURATION ===
# These will be set as environment variables on Render
FINNHUB_API_KEY = os.getenv('FINNHUB_API_KEY')
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')

# Initialize Finnhub client
finnhub_client = finnhub.Client(api_key=FINNHUB_API_KEY)

# Discord bot setup
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# Watchlist file (stored on Render's disk)
WATCHLIST_FILE = 'watchlist.json'

# ====================
# HELPER FUNCTIONS
# ====================

def load_watchlist():
    """Load watchlist from JSON file, or create default if missing."""
    if os.path.exists(WATCHLIST_FILE):
        with open(WATCHLIST_FILE) as f:
            return json.load(f)
    # Default watchlist (you can expand later)
    default = {
        "stocks": ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "VUG"],
        "crypto": ["BINANCE:BTCUSDT", "BINANCE:ETHUSDT", "BINANCE:SOLUSDT", "BINANCE:XRPUSDT", "BINANCE:DOGEUSDT", "BINANCE:PEPEUSDT"]
    }
    save_watchlist(default)
    return default

def save_watchlist(watchlist):
    with open(WATCHLIST_FILE, 'w') as f:
        json.dump(watchlist, f, indent=2)

async def fetch_ohlcv(symbol, timeframe):
    """Fetch OHLCV data from Finnhub."""
    # Map timeframe to Finnhub resolution
    if timeframe == 'daily':
        res = 'D'
        limit = 200
    elif timeframe == 'weekly':
        res = 'W'
        limit = 200
    elif timeframe == '4h':
        res = '60'  # hourly, we'll resample
        limit = 800  # 800 hours = 200 four-hour bars
    else:
        return None

    to_time = int(datetime.now().timestamp())
    from_time = to_time - limit * 24 * 60 * 60  # rough, enough for our needs

    try:
        data = finnhub_client.stock_candles(symbol, res, from_time, to_time)
        if data['s'] != 'ok':
            return None
        df = pd.DataFrame({
            'timestamp': data['t'],
            'open': data['o'],
            'high': data['h'],
            'low': data['l'],
            'close': data['c'],
            'volume': data['v']
        })
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s')
        df.set_index('timestamp', inplace=True)

        if timeframe == '4h':
            # Resample hourly to 4-hour
            df = df.resample('4H').agg({
                'open': 'first',
                'high': 'max',
                'low': 'min',
                'close': 'last',
                'volume': 'sum'
            }).dropna()
        return df
    except Exception as e:
        print(f"Error fetching {symbol}: {e}")
        return None

def calculate_indicators(df):
    """Add EMA, Bollinger Bands, RSI to DataFrame."""
    # EMAs
    df['ema5'] = ta.trend.ema_indicator(df['close'], window=5)
    df['ema13'] = ta.trend.ema_indicator(df['close'], window=13)
    df['ema50'] = ta.trend.ema_indicator(df['close'], window=50)
    df['ema200'] = ta.trend.ema_indicator(df['close'], window=200)

    # Bollinger Bands
    bb = ta.volatility.BollingerBands(df['close'], window=20, window_dev=3)
    df['bb_upper'] = bb.bollinger_hband()
    df['bb_lower'] = bb.bollinger_lband()
    df['bb_basis'] = bb.bollinger_mavg()

    # RSI
    df['rsi'] = ta.momentum.rsi(df['close'], window=14)

    return df

def get_signals(df):
    """Extract latest signals from indicator DataFrame."""
    if len(df) < 2:
        return {}
    latest = df.iloc[-1]
    prev = df.iloc[-2]

    signals = {}
    signals['price'] = latest['close']
    signals['ema5'] = latest['ema5']
    signals['ema13'] = latest['ema13']
    signals['ema50'] = latest['ema50']
    signals['ema200'] = latest['ema200']

    # Crossovers
    signals['ema5_above_13'] = latest['ema5'] > latest['ema13']
    signals['ema13_above_50'] = latest['ema13'] > latest['ema50']
    signals['ema5_cross_above_13'] = prev['ema5'] <= prev['ema13'] and latest['ema5'] > latest['ema13']
    signals['ema5_cross_below_13'] = prev['ema5'] >= prev['ema13'] and latest['ema5'] < latest['ema13']
    signals['ema13_cross_above_50'] = prev['ema13'] <= prev['ema50'] and latest['ema13'] > latest['ema50']
    signals['ema13_cross_below_50'] = prev['ema13'] >= prev['ema50'] and latest['ema13'] < latest['ema50']

    # Bollinger touches
    signals['touch_upper_bb'] = latest['high'] >= latest['bb_upper']
    signals['touch_lower_bb'] = latest['low'] <= latest['bb_lower']

    # RSI
    signals['rsi'] = latest['rsi']
    signals['rsi_overbought'] = latest['rsi'] >= 75
    signals['rsi_oversold'] = latest['rsi'] <= 25

    # Buy/Sell signals
    signals['buy_signal'] = signals['ema5_cross_above_13'] and latest['rsi'] >= 50
    signals['sell_signal'] = signals['ema5_cross_below_13'] and latest['rsi'] <= 50

    # Counts
    bullish = [
        signals['ema5_cross_above_13'],
        signals['ema13_cross_above_50'],
        signals['buy_signal'],
        signals['touch_lower_bb'] and signals['rsi_oversold'],
        signals['rsi_oversold']
    ]
    bearish = [
        signals['ema5_cross_below_13'],
        signals['ema13_cross_below_50'],
        signals['sell_signal'],
        signals['touch_upper_bb'] and signals['rsi_overbought'],
        signals['rsi_overbought']
    ]
    signals['bullish_count'] = sum(bullish)
    signals['bearish_count'] = sum(bearish)
    signals['net_score'] = signals['bullish_count'] - signals['bearish_count']

    return signals

def format_symbol_result(symbol, signals, timeframe):
    """Create a nicely formatted message for a symbol."""
    if not signals:
        return f"`{symbol}`: No data or error."

    # Determine type
    sym_type = "Crypto" if ':' in symbol else "Stock"

    # Emoji based on net score
    if signals['net_score'] >= 2:
        emoji = "ðŸŸ¢ðŸŸ¢"
    elif signals['net_score'] == 1:
        emoji = "ðŸŸ¢"
    elif signals['net_score'] == 0:
        emoji = "ðŸŸ¡"
    elif signals['net_score'] == -1:
        emoji = "ðŸ”´"
    else:
        emoji = "ðŸ”´ðŸ”´"

    lines = [
        f"{emoji} **{symbol}** ({sym_type}) â€“ {timeframe}",
        f"Price: ${signals['price']:.2f}  | RSI: {signals['rsi']:.1f}",
        f"EMAs: 5={signals['ema5']:.2f}, 13={signals['ema13']:.2f}, 50={signals['ema50']:.2f}, 200={signals['ema200']:.2f}"
    ]

    active = []
    if signals['ema5_cross_above_13']: active.append("5â†‘13")
    if signals['ema13_cross_above_50']: active.append("13â†‘50")
    if signals['buy_signal']: active.append("ðŸ“ˆ Buy")
    if signals['touch_lower_bb'] and signals['rsi_oversold']: active.append("ðŸ”» Oversold Triangle")
    if signals['rsi_oversold']: active.append("OS X")

    if signals['ema5_cross_below_13']: active.append("5â†“13")
    if signals['ema13_cross_below_50']: active.append("13â†“50")
    if signals['sell_signal']: active.append("ðŸ“‰ Sell")
    if signals['touch_upper_bb'] and signals['rsi_overbought']: active.append("ðŸ”º Overbought Triangle")
    if signals['rsi_overbought']: active.append("OB X")

    if active:
        lines.append("Signals: " + ", ".join(active))
    else:
        lines.append("No active signals.")

    return "\n".join(lines)

# ====================
# DISCORD COMMANDS
# ====================

@bot.command(name='scan')
async def scan(ctx, target='all', timeframe='daily'):
    """Scan symbols. Usage: !scan all [daily|weekly|4h] or !scan SYMBOL [timeframe]"""
    timeframe = timeframe.lower()
    if timeframe not in ['daily', 'weekly', '4h']:
        await ctx.send("Invalid timeframe. Use daily, weekly, or 4h.")
        return

    watchlist = load_watchlist()
    symbols = watchlist['stocks'] + watchlist['crypto']

    if target.lower() != 'all':
        # Single symbol scan
        symbol = target.upper()
        await ctx.send(f"Scanning **{symbol}** ({timeframe})...")
        df = await fetch_ohlcv(symbol, timeframe)
        if df is None or df.empty:
            await ctx.send(f"Could not fetch data for {symbol}.")
            return
        df = calculate_indicators(df)
        signals = get_signals(df)
        result = format_symbol_result(symbol, signals, timeframe)
        await ctx.send(result)
        return

    # Scan all
    await ctx.send(f"Scanning all symbols ({len(symbols)}) on {timeframe} timeframe. This may take a few minutes. Results will appear as they come.")

    results = []
    for symbol in symbols:
        df = await fetch_ohlcv(symbol, timeframe)
        if df is not None and not df.empty:
            df = calculate_indicators(df)
            signals = get_signals(df)
            if signals and signals['net_score'] != 0:
                result = format_symbol_result(symbol, signals, timeframe)
                results.append(result)
                if len("\n\n".join(results)) > 1800:
                    await ctx.send("\n\n".join(results))
                    results = []
        await asyncio.sleep(1)  # Respect rate limit

    if results:
        await ctx.send("\n\n".join(results))
    await ctx.send("Scan complete.")

@bot.command(name='add')
async def add_symbol(ctx, symbol):
    symbol = symbol.upper()
    watchlist = load_watchlist()
    if ':' in symbol:
        if symbol not in watchlist['crypto']:
            watchlist['crypto'].append(symbol)
            save_watchlist(watchlist)
            await ctx.send(f"Added {symbol} to crypto watchlist.")
        else:
            await ctx.send(f"{symbol} already in crypto watchlist.")
    else:
        if symbol not in watchlist['stocks']:
            watchlist['stocks'].append(symbol)
            save_watchlist(watchlist)
            await ctx.send(f"Added {symbol} to stocks watchlist.")
        else:
            await ctx.send(f"{symbol} already in stocks watchlist.")

@bot.command(name='remove')
async def remove_symbol(ctx, symbol):
    symbol = symbol.upper()
    watchlist = load_watchlist()
    removed = False
    if symbol in watchlist['stocks']:
        watchlist['stocks'].remove(symbol)
        removed = True
    if symbol in watchlist['crypto']:
        watchlist['crypto'].remove(symbol)
        removed = True
    if removed:
        save_watchlist(watchlist)
        await ctx.send(f"Removed {symbol} from watchlist.")
    else:
        await ctx.send(f"{symbol} not found in watchlist.")

@bot.command(name='list')
async def list_watchlist(ctx):
    watchlist = load_watchlist()
    stocks = ", ".join(watchlist['stocks']) if watchlist['stocks'] else "None"
    cryptos = ", ".join(watchlist['crypto']) if watchlist['crypto'] else "None"
    await ctx.send(f"**Stocks:** {stocks}\n**Crypto:** {cryptos}")

@bot.command(name='help')
async def help_command(ctx):
    help_text = """
**5-13-50 Trading Bot Commands**
`!scan all [timeframe]` â€“ Scan all watchlist symbols (shows only non-neutral). Timeframes: daily, weekly, 4h (default daily).
`!scan SYMBOL [timeframe]` â€“ Scan a single symbol.
`!add SYMBOL` â€“ Add a symbol (use BINANCE:XXX for crypto).
`!remove SYMBOL` â€“ Remove a symbol.
`!list` â€“ Show current watchlist.
`!help` â€“ This message.
    """
    await ctx.send(help_text)

@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')

# Run the bot
if __name__ == '__main__':
    bot.run(DISCORD_TOKEN)

Requirements.txt
discord.py
finnhub-python
pandas
numpy
ta

Watchlist.json 
{
  "stocks": ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "VUG", "TSLA", "META", "NFLX", "DIS"],
  "crypto": ["BINANCE:BTCUSDT", "BINANCE:ETHUSDT", "BINANCE:SOLUSDT", "BINANCE:XRPUSDT", "BINANCE:DOGEUSDT", "BINANCE:PEPEUSDT", "BINANCE:ADAUSDT", "BINANCE:DOTUSDT"]
}
